/*
 * [389] Find the Difference
 *
 * https://leetcode.com/problems/find-the-difference/description/
 *
 * algorithms
 * Easy (51.85%)
 * Total Accepted:    118.8K
 * Total Submissions: 229.2K
 * Testcase Example:  '"abcd"\n"abcde"'
 *
 *
 * Given two strings s and t which consist of only lowercase letters.
 *
 * String t is generated by random shuffling string s and then add one more
 * letter at a random position.
 *
 * Find the letter that was added in t.
 *
 * Example:
 *
 * Input:
 * s = "abcd"
 * t = "abcde"
 *
 * Output:
 * e
 *
 * Explanation:
 * 'e' is the letter that was added.
 *
 */

static auto x = []() {
  std::ios::sync_with_stdio(false);
  cin.tie(NULL);
  return nullptr;
}();

/**
 *  Notes for improvement
 *
 *  Nifty bit trick here, something to keep in mind when searching for uniques
 *  It may help to "unroll" computations and see that operations cancel out
 */

#define BIT_MANIPULATION

/**
 *  Hash Map
 *
 *  Time: O(n)
 *  Space: O(n)
 */
#ifdef HASH_MAP
class Solution {
 public:
  char findTheDifference(string s, string t) {
    unordered_map<char, int> freq;
    for (const char c : s) {
      ++freq[c];
    }

    for (const char c : t) {
      --freq[c];
    }

    for (const auto& f : freq) {
      if (f.second != 0) {
        return f.first;
      }
    }
    return '\0';
  }
};
#endif

/**
 *  Bit Manipulation
 *
 *  Nifty trick to find single unique integer from list containing duplicates
 *  s + t = list of duplicate chars where only one char (from t) is unique
 *  Using xor on every char in s + t results in duplicates cancelling out.
 *  For example:
 *    a ^ b ^ c ^ a ^ b ^ c ^ c ^ d
 *  = (a ^ a) ^ (b ^ b) ^ ((c ^ c) ^ c) ^ d
 *  = 0 ^ 0 ^ (0 ^ c) ^ d
 *  = 0 ^ d
 *  = d
 *
 *  Time: O(n)
 *  Space: O(1)
 */
#ifdef BIT_MANIPULATION
class Solution {
 public:
  char findTheDifference(string s, string t) {
    char unique = 0;
    for (const char c : s) unique ^= c;
    for (const char c : t) unique ^= c;
    return unique;
  }
};
#endif
